\documentclass[a4paper,12pt]{article}

% Packages
\usepackage{animate}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bibentry}
\usepackage{color}
\usepackage{dirtree}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyphenat}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage{ipsum}
\usepackage{titlesec}
\usepackage{url}
\usepackage{physics}
\usepackage{subcaption}
\usepackage{float}
\usepackage[normalem]{ulem}
\usepackage[backend=biber, style=apa]{biblatex}
\usepackage[
colorlinks=true,
linkcolor=blue,
urlcolor=cyan,
citecolor=blue,
]{hyperref} % For hyperlinks

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{
	aboveskip=3mm,
	basicstyle={\small\ttfamily},
	belowskip=3mm,
	breakatwhitespace=true,
	breaklines=true,
	columns=flexible,
	commentstyle=\color{dkgreen},
	frame=none,
	keywordstyle=\color{blue},
	language=C++,
	numbers=none,
	numberstyle=\tiny\color{gray},
	showstringspaces=false,
	stringstyle=\color{mauve},
	tabsize=4
}
\addbibresource{references.bib}
\geometry{margin=1in}
\titleformat{\chapter}[display]
{\normalfont\huge\bfseries}{\chaptertitlename\ \thechapter}{20pt}{\Huge}
\titlespacing{\chapter}{0pt}{0pt}{0pt}
\newcommand{\sectionbreak}{\clearpage}

% Title and Author
\title{Computational Fluid Dynamics With a Paper Airplane}
\author{
  Tasada, Daniel\\
  \and
  Tse, Nathan\\
}
\date{\today}

\begin{document}

% Title and abstract
\maketitle
\begin{abstract}
	In this paper, we investigate the relationship between an airplane's shape
	and its performance. Our results show that \dots
\end{abstract}

% Table of Contents
\tableofcontents

% Introduction
\section{Introduction}
This thesis covers the simulation of the aerodynamics of an airplane, using
our own Computation Fluid Dynamics (or CFD) model.

The goal is to calculate the ideal shape of an airplane for its aerodynamic
performance. We aim to do this by creating a Machine Learning model, and feed
it the results of the CFD, which should result in our final model.

The thesis questions are the following:
\begin{itemize}
	\item{How do the different aspects of fluid dynamics work and how do we
		implement it in a computer program?}
	\item{How do we dynamically generate 3D models?}
	\item{How does an airplane's wing shape influence its performance?}
\end{itemize}

% Execution
\section{Execution}
\subsection{Preliminary: Lagrangian Fluid Simulation}
Our first attempt at a fluid simulator was using a technique called Lagrangian
fluid simulation. This involves simulating the fluid as a particle collision
simulation. It regards fluid dynamics, as particle physics, where every air
molecule is a "particle". We start with a container, and a bunch of air molecules,
all of which interact with each other to create a fluid. This interaction is
effectively the collisions between particles. It turns out that simulating
particle dynamics in two dimensions is pretty straightforward. But when you
throw in that Z-axis, it gets a lot harder. The main article we used for this is
\hyperlink{http://www.hakenberg.de/diffgeo/collision_resolution.htm}{Rigid Body Collision Resolution} (\cite{hakenberg}).

Here is a set of formulas necessary to perform the calculations that describe
the behavior of a pair particle before and after their collision:

The following variables are necessary to perform the calculations:
\[
\begin{array}{ll}
    \text{Inertia tensor $I$ } (kg\cdot m^2): & L = \frac{L}{\omega}; \\
    \text{Angular momentum $L$ } (kg\cdot m^2/s): & L = mvr; \\
    \text{Angular velocity $\omega$ } (rad/s): & \omega = \frac{\Delta \theta}{\Delta t}; \\

	\\

	\text{Collision normal} (n \in \mathbb{R}^3) \text{ in world coordinates away from body 1}; \\
	\text{Point of contact } (r_i \in \mathbb{R}^3) \text{ in world coordinates with respect to $p_i$}; \\
	\text{Orientation } (R_i \in SO(3)) \text{ transforming from object to world coordinates}; \\
\end{array}
\]

Where $i$ represents one of two particles in a given collision:
\[
\begin{array}{ll}
	\text{Velocity after collision} & \tilde{v}_i, \\ 
	\text{Angular velocity after collision} & \tilde{\omega}_i, \\
	\text{Constant} & \lambda, \\
\end{array}
\]

The following formulas represent the relation between particles:
\[
\begin{array}{cc}
	\tilde{v}_1 = v_1 - \frac{\lambda}{m_1} n; \\ 
	\tilde{v}_2 = v_2 + \frac{\lambda}{m_2} n; \\
	\tilde{\omega}_1 = \omega_1 - \Delta q_1; \\
	\tilde{\omega}_2 = \omega_2 + \Delta q_2; \\

	\text{where } q_i := I_i^{-1} \cdot R_i^{-1} \cdot (r_i\times n), \\
	\text{and } \lambda = 2 \frac{n v_1 - n v_2 + \omega_1 I_1 q_1 - \omega_2 I_2 q_2}
	{(\frac{1}{m_1} + \frac{1}{m_2})n^2 + q_1 I_1 q_1 + q_2 I_2} \\
\end{array}
\]

After lots of trial and error, we were able to successfully implement the math.
We did this using Go and raylib, and the code is available at
\verb|github.com/dtasada/paper| at the \verb|lagrangian-go| branch.
But we encountered a simple issue where the particles would phase into each other,
rendering the particle simulation worthless.
This could be because of a too small time step, or a logic error in the collision
detection. This should be fixable by adding more simulation steps, which means
that each particles solves its collisions more than once per collision, but we
weren't able to successfully implement this. In the end, we ended up scrapping
the Lagrangian simulation model.

\subsection{Eulerian Fluid Simulation}
Next we tried a method that we'd had our eyes on for a while. This was had
originally been our first choice, but we switched to Lagrangian due to problems
I'll explain shortly. It's called Eulerian fluid simulation, and the way this
model works is that it sees fluid as a grid of cells that react to each other.
Eulerian fluid simulation is an application of cellular automata, which is a
computation model used in physics, biology, and many other applications.
Our fluid simulation involves a three-dimensional grid of cells, altough we will explain the concepts that are used using a 2 dimensional grid.
Each of the cells in the grid have a velocity and density component.
Each frame, the cells interact with each other according to the
\hyperlink{https://en.wikipedia.org/wiki/Navier\%E2\%80\%93Stokes_equations}{Navier-Stokes equations}.
The math involved in the Navier-Stokes equations is very complex and
difficult to understand without a good background in physics and differential
equations. That is why the reader is not expected to fully understand these equations. 
Most of the math that we will explain is from Mike Ash's
\hyperlink{https://mikeash.com/pyblog/fluid-simulation-for-dummies.html}{Fluid Simulation for Dummies}
(\cite{mikeash}), which is in turn based on Jos Stam's brilliant work on
\hyperlink{http://graphics.cs.cmu.edu/nsp/course/15-464/Fall09/papers/StamFluidforGames.pdf}{Real-Time Fluid Dynamics for Games} (\cite{josstam}).

% Math
\subsubsection{The Math} \label{math}
In Eularian fluid dynamics we represent fluids with a velocity vector field. This means we assign a velocity vector to every point in space.
The Navier-Stokes equations show us how these velocity vectors evolve over time with an infinitely small time step.
\[
\begin{array}{ll}
	\dv{u}{t} = -(u \cdot \nabla)u + v\nabla^2 + f \\
  \\
  \dv{\rho}{t} = -(u \cdot \nabla)\rho + k\nabla^2\rho + S
\end{array}
\]
The first equation returns the change in velocity in a vector notation. 
Unlike in Lagrangian fluid simulation, in Eularian fluid simulation the fluid is not represented by individual particles. 
Thats why, instead, fluid density is used, which tells us the amount of particles present in a point in space. 
The second equation shows us the change of this density. 
Although to understand the math behind this simulation it isn't needed to fully understand these equations, it should be noted that the two equations above look a lot like each other,
as this was helpful in developing the simulation. (\cite{josstam})

\begin{figure}[H]
\centering
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[width=5cm]{resources/collocated_grid_2.png}
	\caption{Collocated grid}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
	\centering
	\includegraphics[width=5cm]{resources/staggered_grid_2.png}
	\caption{Staggered grid}
\end{subfigure}
\caption{Computational grids}
\end{figure}

There are two different types of velocity vector fields we can use: collocated and staggered.
In the collocated grid all the variables are stored in the center of the cell. 
Whereas in the staggered grid the scalar variables are stored at the center but the velocity variable is stored at the cell face. 
Usually the use of a staggered grid is preferred, because its easier to see how much fluid flows from one cell to another. (\cite{tenminute})
However because Mike Ash and Jos Stam used a collocated grid in their works we decided to use the same grid for simpliciy sake. \\

\subsubsection{Density Solver} \label{density}

First, lets look at the density solver. The density solver follows three steps: first adding forces, secondly diffusion and lastly moving the densities. 
If we look at the density equation in figure 1, we see that the change in density in a single time steps is influenced by three terms. 
The first term states that the density should follow the velocity field,
the second term represents the density's rate of diffusion
and the third term says that the density can increase due to sources. 
The density solver will apply these terms in reverse order. 
So, as stated before, first the forces are added, then the diffusion is applied and finally the densities are moved. \\

\textbf{Adding Forces} \\

The first step is adding forces from a source. In our case forces will be added if the user clicks on the screen.
If that happens we will simply add a constant amount of density to the intial density. So:   \\

\[
\begin{array}{ll}
  \rho_{t+dt} = \rho_t + S \cdot dt
\end{array}
\] \\

\textbf{Diffusion} \\

The second step is diffusion.
Diffusion is the process where spread the fluid from high density cells to low density cells.
The diffusion happens at a constant rate that we will call \textit{D}. 
Now we can simply calculate the diffusion rate \textit{a} by multiplying it with the time step:

\[
\begin{array}{ll}
  a = dt \cdot D
\end{array}
\] \\

If we take a look at a single cell, we'll see that it exchanges densities with its four neighbors.
The total difference of the densities between the cell and its neighbours can be calculated by the following formula,
where $\rho_{x, y}$ is the current density of the cell at position (x, y):

\[
\begin{array}{ll}
	\rho_{x+1, y} + \rho_{x-1, y} + \rho_{x, y+1} + \rho_{x, y-1} - 4 \cdot \rho_{x, y}
\end{array}
\]  \\

By multiplying the difference in densities with the diffusion rate \textit{a} and adding it to the current density, we calculate new density of the cell. 
This can be seen in the following formula, where P$_{x, y}$ is equal to the density of cell at position (x, y) after the time step: \\

\[
\begin{array}{ll}
	P_{x, y} = \rho_{x, y} + a \cdot (\rho_{x+1, y} + \rho_{x-1, y} + \rho_{x, y+1} + \rho_{x, y-1} - 4 \cdot \rho_{x, y})
\end{array}
\]  \\

But here we run into a problem. If the diffusion rate is big enough the density in a cell might end up becoming negative.
Imagine, for example, a situation wehere the diffusion rate is equal to 1,  the density of a cell is 1 and the densities of its neighbors are all 0. This means that the density of the cell will become -3.
This of course is not possible.
The solution to this problem is to find the density of the cell when being diffused backwards in time. Which results in the following equation: \\

\[
\begin{array}{ll}
	\rho_{x, y} = P_{x, y} + a \cdot (P_{x+1, y} + P_{x-1, y} + P_{x, y+1} + P_{x, y-1} - 4 \cdot P_{x, y})
\end{array}	
\] \\

To solve this system of lineair equations for the unknowns P$_{x, y}$ the \hyperlink{https://en.wikipedia.org/wiki/Gaussâ€“Seidel_method}{Gauss-Seidel method} is used. 
(\cite{josstam}) \\

\textbf{Advection }\\

The final step of the density solver is moving the densities following the velocity field.
Because you can't really move grid cells, we will use a technique where we represent a density as a set of particles.
An obvious way to move the densities is to act like the center of a cell is a particle and move it through the velocity field.
But because we have to convert the particles back to a grid, we will use a different method. 
This method is called semi-lagrangian advection.
We will first look at the particles that end up at the center of a cell and use the velocity of the cell to trace the particles one time step back in time.
Then we will look at where the particles end up and calculate the weighted average of the densities of the four closest cells from a particle and set this as the new density of the current cell. 
To do this we need to use two different grids: one that contains all the density values from the previous time step
and on that contains the new density values. (\cite{josstam})

 \subsubsection{Velocity Solver}
Now we will look at the velocity solver. Just like with the density solver if we look at the equations in section \ref{math}
we see that the change in velocity in a single time step is influenced by three factors. 
These are: the addition of forces, viscous diffusion and self-advection. 
Because the velocity equation looks so much like the density equation we can use the same steps that we're shown in section \ref{density} to solve it.
The only difference is that the velocity solver has an extra step called projection. \\

\textbf{Projection }\\

This step ensures that mass is conserved. 
The law of conservation of mass is an important property of real-life fluids.
The projection step will be the last step that is executed because the previous steps might not always conserve mass.
To make the fluid mass conserving we will use a mathematical concept called Hodge decomposition.
Hodge composition states that every vector field is the sum of a mass conserving field and a gradient field.
So all we have to do is compute a gradient field and subtract it from the velocity field. 
The gradient field 
Computing the gradient field involves the solution of a lineair system called a Poisson equation.
To solve this system we will we again use the Gauss-Seidel method that was also mentioned in section \ref{density} in the diffusion step. (\cite{josstam})

\subsubsection{The Implementation}
Our code is structured as follows:
\dirtree{%
	.1 paper.
	.2 simulation/\DTcomment{Contains the physics simulation code}. 
	.3 include/\DTcomment{Our own engine headers}.
	.3 lib/\DTcomment{External libraries}.
	.3 resources/\DTcomment{Resources like images, fonts, shaders}.
	.3 src/\DTcomment{Actual engine source}.
	.3 config.toml\DTcomment{Configuration file}.
	.3 Makefile.
	.2 neural\DTcomment{Contains ML engine}.
}

The code is written in C++, and uses the \hyperlink{https://www.raylib.com/}{raylib}
library for easy 3D rendering.
We originally wanted to use Go because of preference and developer ergonomics,
which is what we did with the first Lagrangian model, but we ended up writing
the physics simulation in C++ because of the way that Jos Stam's implementation
utilizes 3D arrays, which we found not to be viable in Go, which is why we
switched to the Lagrangian model in the first place.

The main class we use for the simulation is the \verb|Fluid| class. The implementation
is available at \verb|/simulation/src/Fluid.cpp|. The interface is as follows: \\
\begin{center}
	\includegraphics[width=\textwidth]{resources/Fluid.png}
\end{center}

The class contains the cell property fields as well as all the functions related
to the physics simulation, including the advection, diffusion and projection procedures.
With this we have a basic working fluid simulator.

The next step is to add geometry. We did this by adding a boolean field to the
Fluid properties and some getters and setters.
\begin{lstlisting}
class Fluid {
   private:
	// rest of private members
	bool *solid;

   public:
	// rest of public members
	bool is_solid(v3 position);
	void set_solid(v3 position, bool set);
}
\end{lstlisting}
Then we change the advection and boundary handling functions to account for
solid boundaries. This is done by checking whether each cell is solid, and if
so, the cell properties aren't advected.

\begin{lstlisting}
// in advection function, for each cell:
if (solid[IX(i, j, k)]) {
	if (b != FieldType::DENSITY) {  // For velocity components
		d[IX(i, j, k)] = 0;
	}
	continue;
}

// in boundary function, for each cell:
if (solid[IX(x, y, z)]) {
	// For velocity components, enforce no-slip condition
	if (b == FieldType::VX) f[IX(x, y, z)] = 0;  // x velocity
	if (b == FieldType::VY) f[IX(x, y, z)] = 0;  // y velocity
	if (b == FieldType::VZ) f[IX(x, y, z)] = 0;  // z velocity

	// For density and pressure, use average of neighboring
	// non-solid cells
	if (b == FieldType::DENSITY) {
		float sum = 0;
		int count = 0;

		if (!solid[IX(x-1, y, z)]) { sum += f[IX(x-1, y, z)]; count++; }
		if (!solid[IX(x+1, y, z)]) { sum += f[IX(x+1, y, z)]; count++; }
		if (!solid[IX(x, y-1, z)]) { sum += f[IX(x, y-1, z)]; count++; }
		if (!solid[IX(x, y+1, z)]) { sum += f[IX(x, y+1, z)]; count++; }
		if (!solid[IX(x, y, z-1)]) { sum += f[IX(x, y, z-1)]; count++; }
		if (!solid[IX(x, y, z+1)]) { sum += f[IX(x, y, z+1)]; count++; }

		f[IX(x, y, z)] = count > 0 ? sum / count : f[IX(x, y, z)];
	}
}
\end{lstlisting}

This allows us to add a cube of a given size at a given position, which the
fluid will treat as a solid object. Unfortunately, a plane is more complex than
a cube. There are a few ways to handle this. The most obvious and least efficient
is to raise the resolution of the grid. Currently we've been experimenting with a
24x24x24 or a 32x32x32 grid, and that's already not as performant as we'd like.
A 24x24x24 grid has to iterate $24^3 = 13824$ times per frame. And to simulate
complex shapes, the higher resolution the better. But simply increasing the
resolution to something like 128x128x128 or higher just isn't viable.

We're still implementing this at the time of writing the concept, but the goal
is to use the method explained above in combination with the Cut-Cell method,
which will dynamically create more of these cells along the borders of the model,
in this case a plane. This would create a high-resolution grid near the important
and complex areas of the simulation, while preserving resources by keeping the
unimportant areas (like large patches of just air) from being computed.

% Results
\section{Results}
\ipsum[1]

% Conclusion
\subsection{Conclusion}
\ipsum[1]

% References
\nocite{*}
\printbibliography

\end{document}
